#     Поведенчески шаблони за дизайн
##    Template Method Pattern
### Цел на шаблона
* Шаблонният метод (‘Template Method’) позволява разделянето на имплементацията на алгоритъм на 2 нива. Логиката на алгоритъма е реализирана в базов родителски клас. Поведението на обектите в стъпките, специфични за конкретните наследници, е отложено за имплементация в самите тях.

### Приложимост
Най-често Шаблонен метод се използва, когато:

*	Имаме сложен логически алгоритъм. Логично следва да зададем стъпките на алгоритъма в родителския клас и оставим на наследниците да реализират поведението на стъпките, които са конкретни за самия наследник.
*	Искаме да направим кода по-универсален. Да преизползваме код, като изолираме общите части на едно място ("refactoring to generalize"). В Шаблонния метод изолираме код, споделен от наследниците на даден клас в родителя.
*	Имаме нужда от контрол на родителския клас над класовете наследници. Искаме да не даваме контрола на наследниците на клас за определени критични методи по една или друга причина.

### Описание
* Шаблонът за дизайн “Шаблонен Метод” представлява реализирането на логически алгоритъм чрез метод, който е общ и остава непроменен за всички наследници. Този метод наричаме „Шаблонен”. Шаблонният метод е реализиран в родителски клас. В рамките на Шаблонния метод могат да бъдат извиквани няколко примитивни (елементарни) операции на обекта. Реализацията им обикновено е отложена за наследниците. 
* Примитивни/елементарни операции (‘elementary operations’) наричаме тези стъпки, които са характерни за конкретни поднаследници. Това съвсем не означава, че логиката в тях е елементарна. Но означава, че тази стъпка може логически да се изолира като една стъпка в шаблонния метод и това да не повлияе на логиката на самия Шаблонен метод. 
* Базовият клас задава и имплементира логиката на изпълнение на определен алгоритъм в Шаблонен метод. Отделните примитивни стъпки могат да бъдат или да не бъдат предефинирани в наследниците. Това зависи от конкретното приложение. 
* „Холивудски принцип” (Hollywood principle) -  Класът-наследник не се обръща към шаблонния метод. Шаблонния метод бива извикан и той се обръща към различни методи в наследниците, когато те са необходими за конкретна стъпка от алгоритъма. Това обръщане на контрола е така-нареченият „Холивудски принцип”.

###  Участници
* Абстрактен клас (AbstractClass) - Това е класът, в който е реализиран самият Шаблонен метод. Абстрактен е, тъй като в него като абстрактни са оставени примитивните операции, които задължително трябва да са предефинирани в наследниците.
* Конкретен абстрактен клас (ConcreteClass) -  Абстрактният клас не може да бъде инстанцииран и именно в него е имплементиран шаблонният метод, който е носителят на основната логика.
* Клас-наследник - Конкретният клас е подклас на Абстрактния клас. В него се реализират примитивните абстрактни операции от родителския клас (специфични стъпки от Шаблонния метод, характерни за самият подклас). В него също може да са реализирани част от операциите, оставени като „вратички“ (hooks) в Шаблонния метод. Тези операции не са абстрактни и, съответно, не са задължителни за имплементация. 
* „Абстрактните примитивни операции”(abstract primitive operations) - При имплементирането на Шаблонния метод това са методи, които са декларирани като абстрактни. Те нямат тяло в базовия родителски клас, съдържащ шаблона. Тяхното имплементиране е отложено за конкретен подклас. 
* Вратички (hooks) -  Понякога в имплементацията на Шаблонния метод се оставят методи, начечени „вратички” (hooks), чрез които е възможно добавяне на допълнителна логика в шаблонния метод. Това са стъпки, извиквани в Шаблонния метод, чието тяло се оставя празно. Те не са абстрактни, т.е. подкласовете не са задължени да ги реализират. Но, при желание, те могат да се „пренаписват” (“override”) в наследниците, за да се промени хода на Шаблонния Метод. Така се дава възможност за правенето на необходими промени в алгоритъма.

### Силни страни
*	Намалява повторението на една и съща логика на различни места из кода.
*	Позволява преизползване, което е основна цел при използване на шаблони за софтуерен дизайн.
*	Ограничава възможността от грешки в алгоритъма, като освен единичното реализиране на имплементацията, не позволява логиката му да се променя на критичните места, на които не трябва.
*	Дава свобода за модифициране и гъвкавост спрямо ситуацията чрез оставените „вратички” (hooks) и абстрактни операции (“abstract operations”).
*	Осигурява контрол върху логика, която е желателно да не бъде променяна от наследниците на класа.

### Слаби страни
*	Употребата на наследяването е задължителна за имплементацията на Шаблонния метод. Това обаче, особено при езици, където няма множествено наслядяване, е много силно ограничение. 
*	Наследяването, абстракцията, обръщането на контрола – това води неминуемо и до усложняване на кода. Ако този, който чете кода, не е запознат с Шаблонният метод и неговата структура, то е възможно да се наложи допълнително обяснение.

### Свързани шаблони
*	„Стратегия“ (Strategy) - Стратегията като шаблон за дизайн представлява дефиниране на стъпките от метод в интерфейс, който може да се реализира от много и различни класове. Самата реализация на алгоритъма „Стратегия”, обаче, е поверена на класовете, които имплементират този интерфейс. За разлика от него, при Шаблонния метод той е изцяло имплементиран веднъж в родителския клас. Но при употреба на Шаблонния метод класовете задължително трябва да са наследници на базовият клас, докато при „Стратегия” различни класове (разширяващи различни базови класове) могат да имплементират и имплементират една и съща стратегия. В резултат „Стратегията“ (Strategy) е много по-гъвкава при употреба. Шаблонният метод има преимуществото на по-силен контрол върху реализирания алгоритъм и позволява части от кода да не бъдат променяни от наследниците.
* „Метод фабрика“ (Factory Method) - При методa-фабрика създаването на сложни обекти е реализирано през един клас, като в зависимост от реалния тип на обекта, този клас извиква конкретни конструктори и методи, за да го създаде с подходящите параметри. В шаблонните методи често се извикват методи-фабрики, които от своя страна извикват методите на конкретния клас.
* „Строител“ (Builder) - Строителят се използва при създаването на сложни логически обекти, за да се „скрие“ тази сложност и да се раздели създаването на обекта от логиката по използването му. Всъщност Строителят е много близък по логика до Шаблонния метод. Бихме могли да разглеждаме Строителя като частен случай на шаблонен метод.


